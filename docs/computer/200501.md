---
title: 基于Node.js的网络编程
sidebar: 'auto'
date: 2020-03-25
author: Issho Lin
tags:
 - 网络
categories:
 - 计算机基础
---

>传统的Web平台大多数都需要专门的Web服务器作为容器，如ASP、ASP.NET需要IIS作为服务器，PHP需要搭载Apache或Nginx环境等。Node可以非常方便的搭建网络服务器。Node提供了net、dgram、http、https四个模块，分别处理TCP、UDP、HTTP、HTTPS，适用于服务器端和客户端。
## 一、Node.js网络通信概述
### 1、网络七层模型（OSI参考模型）
应用层：为应用程序提供服务（上层数据）
表示层：数据格式转化、数据加密
会话层：建立、管理和维护会话
传输层：建立、管理和维护端到端的连接（TCP头部、上层数据）
网络层：IP选址及路由选择（IP头部、TCP头部、上层数据）
数据链路层：提供介质访问和链路管理（MAC头部、IP头部、TCP头部、上层数据、尾部）
物理层：物理层（0和1电信号）
### 2、层与协议
每一层都是为了完成一种功能。为了实现这些功能，就需要大家都遵守共同的规则。，大家都遵守的规则，就叫做“协议”（protocol）。
互联网的每一层，都定义了很多协议，这些协议的总称，就叫做互联网协议“”（Internet Protocol Suite）。他们是互联网的核心，下面介绍每一层的功能，主要就是介绍每一层的主要协议。
### 3、实体层（物理层）
电脑要组网，第一件事要干什么？当然是先把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。这就叫做“实体层”，它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。
### 4、链接层（数据链路层）
单纯的0和1没有任何意义，必须规定解读方式，多少个电信号算一组？每个信号位有何意义？这就是“链接层”的功能，它在“实体层”的上方，确定了0和1的分组方式。
#### 以太网协议
早期的时候，每家公司都有自己的电信号分组方式，逐渐地，一种叫做“以太网”（Ethernet）的协议，占据了主导地位。以太网规定，一组电信号构成一个数据包，叫做“帧”（Frame）。每一帧分成两个部分，标头（Head）和数据（Data）。
“标头”包含数据包的一些说明，比如发送者、接受者、数据类型等等；“数据”则是数据包的具体内容。
“标头”的长度，固定为18字节。“数据”的长度，最短为46字节，最长为1500字节。因此，整个“帧”最短为64字节，最长为1518字节，如果数据很长，就必须分割成多个帧进行发送。
#### MAC地址
以太网数据包的“标头”，包含了发送者和接受者的信息，那么，发送者和接受者是如何标识的呢？
以太网规定，连入网络的所有设备，都必须具有“网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接受地址，这就叫做“MAC地址”。
每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。
#### 广播
以太网数据包也必须知道接收方的MAC地址，然后才能发送。
首先，一块网卡怎么会知道另一块网卡的MAC地址？其次，就算有了MAC地址，系统怎样才能把数据包准确送到接收方？
回答是以太网采用了一种很“原始”的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。
### 5、网络层
以太网协议，依靠MAC地址发送数据。理论上，单单依靠MAC地址，上海的网卡就可以找到洛杉矶的网卡了，技术上是可以实现的。
但是，这样做有一个重大的缺点。以太网采用广播方式发送数据包，所有成员人手“一包”，不仅效率低，而且是局限在发送者所在的子网络。也就是说，如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理的，否则在互联网上每一台计算机都会收到所有包，那会引起灾难。
互联网是无数子网络共同组成的一个巨型网络，很难想象上海和洛杉矶的电脑会是在同一个子网络，这几乎是不可能。
因此，必须找到一种方法，能够区分哪些MAC地址属于哪一个子网络，哪些不是。如果是同一个子网络，就采用广播的方式发送，否则就采用“路由”方式发送。（“路由”的意思，就是指如何向不同的子网络分发数据包）遗憾的是，MAC地址本身无法做到这一点，它只与厂商有关，与所处网络无关。
这就导致了“网络层”的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做“网络地址”，简称“网址”。
于是，“网络层”出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。
网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包发送到子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。
#### IP协议
规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为“IP地址”。
目前，广泛采用的是IP协议第四版，简称IPV4。这个版本规定，网络地址由32个二进制位组成。
习惯上，我们用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255.
IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。
### 6、传输层
#### 端口
有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。
接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？
也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做“端口”（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己需要的数据。
“端口”是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。
“传输层”的功能，就是建立“端口到端口”的通信。相比之下，“网络层”的功能是建立“主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机+端口，叫做“套接字”（socket）。有了它，就可以进行网络应用程序开发了。
#### UDP协议
现在，我们必须在数据包中加入端口信息，这就需要新的协议，最简单的实现叫做UDP协议，它的格式几乎就是在数据前面加上端口号。
UDP数据包，也是由“标头”和“数据”两部分组成。“标头”部分主要定义了发出端口和接收端口。“数据”部分就是具体的内容。然后，把整个UDP数据包放入IP数据包的“数据”部分，而前面说过，IP数据包又是放在以太网数据包之中的。
UDP数据包非常简单，“标头”部分一共只有8个字节，总长度不超过65535个字节，正好放进一个IP数据包。
#### TCP协议
Transmission Control Protocol 传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议。
UDP是不可靠的，而TCP则保证了数据的可靠性。
### 7、应用层
应用程序收到“传输层”的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。
“应用层”的作用，就是规定应用程序的数据格式。
举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、www、FTP等等。那么，必须有不同协议规定电子邮件，网页，FTP数据的格式，这些应用程序协议就构成了“应用层”。
这是最高的一层，直接面对用户。它的数据就放在TCP数据包的“数据”部分。因此，现在的以太网的数据包就变成了：以太网标头+IP标头+TCP标头+应用层数据包。
至此，整个互联网的五层结构，自下而上全部讲完了。这是从系统的角度，解释互联网是如何构成的。

## 二、构建TCP服务
### 1、三次握手连接
![image.png](https://upload-images.jianshu.io/upload_images/19423820-5aafc49190e5b61f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
### 2、使用net模块构建TCP服务端和客户端
服务端server.js
```js
// 导入node的net模块
const net = require('net')
// 创建服务
const server = net.createServer()
// 监听连接请求
server.on('connection', clientSocket => {
    console.log('已连接...')
    // 监听 clientSocket 的 data 事件，接收客户端发送的数据
    clientSocket.on('data', data => console.log(`客户端发来了：${data.toString()}`))
    // 通过 clientSocket 给当前连接的客户端发送数据
    clientSocket.write('I am the server')
})
// 绑定端口号
server.listen(8080, () => console.log('Server running 127.0.0.1 8080'))
```
客户端client.js
```js
const net = require('net')
// 创建连接
const client = net.createConnection({
    host: '127.0.0.1',
    port: '8080'
})
// 监听连接
client.on('connect', () => {
    console.log('已连接到服务器...')
    // 当客户端与服务端建立连接之后，客户端就可以给服务端发送数据了
    client.write('I am the client')
    // 当客户端与服务端建立连接成功以后，我们可以监听终端的输入，然后获取终端的输入发送给服务端
    process.stdin.on('data', data => {
        console.log(`发给服务端：${data.toString()}`)
        client.write(data.toString().trim())
    })
})
// 监听data事件，接收服务端发送的数据
client.on('data', data => console.log(data.toString()))
```
## 三、构建UDP服务
## 四、构建HTTP服务
## 五、构建WebSocket服务
## 六、构建HTTPS服务