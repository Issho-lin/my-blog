---
title: 事件循环
sidebar: 'auto'
date: 2020-03-25
author: Issho Lin
tags:
 - EventLoop
categories:
 - Javascript
---

## 一、事件循环是什么
各种浏览器事件同时触发时，肯定有⼀个先来后到的排队问题。决定这些事件如何排队触发的机制，就是事件循环。
这个排队⾏为以 JavaScript 开发者的⻆度来看，主要是分成两个队列：
- ⼀个是 JavaScript 外部的队列。外部的队列主要是浏览器协调的各类事件的队列，标准⽂件中称之为**Task Queue**。下⽂中为了⽅便理解统⼀称为**外部队列**。
- 另⼀个是 JavaScript 内部的队列。这部分主要是 JavaScript 内部执⾏的任务队列，标准中称之为**Microtask Queue**。下⽂中为了⽅便理解统⼀称为**内部队列**。
值得注意的是，虽然为了好理解我们管这个叫队列 (Queue)，但是本质上是有序集合 (Set)，因为传统的队列都是先进先出（FIFO）的，⽽这⾥的队列则不然，排到最前⾯但是没有满⾜条件也是不会执行的（⽐如外部队列⾥只有⼀个 setTimeout 的定时任务，但是时间还没有到，没有满⾜条件也不会把他出列来执⾏）。
### 外部队列
外部队列（Task Queue），顾名思义就是 JavaScript 外部的事件的队列，这⾥我们可以先列举⼀下浏览器中这些外部事件源（TaskSource），他们主要有：
- DOM 操作 (⻚⾯渲染)
- ⽤户交互 (⿏标、键盘)
- ⽹络请求 (Ajax 等)
- History API 操作
- 定时器 (setTimeout 等)
可以观察到，这些外部的事件源可能很多，为了⽅便浏览器⼚商优化，HTML 标准中明确指出⼀个事件循环由⼀个或多个外部队列，⽽每⼀个外部事件源都有⼀个对应的外部队列。不同事件源的队列可以有不同的优先级（例如在⽹络事件和⽤户交互之间，浏览器可以优先处理⿏标⾏为，从⽽让⽤户感觉更加流程）。
### 内部队列
内部队列（Microtask Queue），即 JavaScript 语⾔内部的事件队列，在 HTML 标准中，并没有明确规定这个队列的事件源，通常认为有以下⼏种：
- Promise的成功 (.then) 与失败 (.catch)
- MutationObserver
- Object.observe (已废弃)