---
title: 重学js系列之《JavaScript高级程序设计(第四版)》(4~7)
sidebar: 'auto'
date: 2021-09-22
author: Issho Lin
tags:
 - 重学js
categories:
 - Javascript
---


# 四、变量、作用域与内存
## 4.1 原始值与引用值

- 原始值：大小固定，存储在栈内存中，按值访问，操作的是存储在变量中的实际值
    - Undefined
    - Null
    - Boolean
    - Number
    - String
    - Symbol
- 引用值：保存在内存中的对象，按引用访问，操作的是对该对象的引用而非实际的对象本身

> JavaScript不允许直接访问内存位置，因此不能直接操作对象所在的内存空间

### 1. 动态属性
```js
// 给对象动态添加name属性
const person = new Person()
person.name = 'lin'
console.log(person.name) // lin

// 原始值不能有属性，动态添加属性无效
const name = 'lin'
name.age = 25
console.log(name.age) // undefined
```
### 2. 复制值
- 原始类型：复制值的副本，相互独立
```js
let num1 = 5
let num2 = num1
console.log(num1, num2) // 5, 5
num2 = 6
console.log(num1, num2) // 5, 6
```

- 引用类型：复制指针副本，指向堆内存中的同一个对象
```js
let obj1 = new Object()
obj1.name = 'lin'
let obj2 = obj1
console.log(obj1.name, obj2.name) // lin, lin
obj2.name = 'wang'
console.log(obj1.name, obj2.name) // wang, wang
```

### 3. 传递参数
ECMAScript中所有函数的参数都是按值传递的。

- 原始类型：复制值的副本赋值给函数形参
```js
function setNum(num) {
    num += 10
    return num
}

let count = 5
const res = setNum(num)

console.log(count, res) // 5, 15
```
- 引用类型：复制指针的副本赋值给函数形参，不能理解为按引用传递
```js
function setName(obj) {
    obj.name = 'lin'
    obj = {
        name: 'li'
    }
    return obj
}
const o = {
    name: 'wang'
}
const res = setName(o)
console.log(o.name, res.name) // lin, li
```
> ECMAScript中函数的参数就是局部变量

### 4. 确定类型
- typeof：适用于原始值，对于数组，对象和null都返回'object'
```js
typeof 'a' // string
typeof(1) // number
```
- instanceof：检测在A的原型链上是否能找到`B.prototype`
```js
// A instanceof B
let arr = []
arr instanceof Array // true
// arr.__proto__ === Array.prototype
let obj = {}
obj instanceof Object // true
```

## 4.2 执行上下文与作用域
每个函数调用都有自己的上下文，当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。
上下文中的代码在执行的时候，会创建变量对象的一个作用域链。
- 全局上下文
- 函数上下文
- 块级上下文
```js
let color = 'blue'
function changeColor() {
    let anotherColor = 'red'
    function swapColors() {
        let tempColor = anotherColor
        anotherColor = color
        color = tempColor
        // 这里可以访问color、anotherColor和tempColor
    }
    // 这里可以访问color和anotherColor，但访问不到tempColor
    swapColors()
}
// 这里只能访问到color
changeColor()
```
作用域示意图：

![image.png](https://res.weread.qq.com/wrepub/epub_34336683_27){width=250}

### 1. 作用域链增强
这两种情况会在作用域链前端添加一个变量对象，并在代码执行后删除
- try/catch语句的catch块
- with语句

### 2. 变量声明
- var函数作用域声明
```js
function add(num1, num2) {
    var sum = num1 + num2
    return sum
}
var res = add(1, 2)
console.log(res) // 3
console.log(sum) // Uncaught ReferenceError: sum is not defined
```
如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文
```js
function add(num1, num2) {
    sum = num1 + num2
}
add(1, 2)
console.log(sum) // 3
```
var声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前
```js
console.log(name) // undefined
var name = 'lin'
// 等价于
var name
console.log(name)
name = 'lin'
```
var在全局作用域声明的变量会被挂载到window对象上
```js
var name = 'lin'
console.log(window.name) // lin
```
- let块级作用域声明

块级作用域由最近的一对包含花括号{}界定
```js
{
    let name = 'lin'
}
console.log(name) // Uncaught ReferenceError: name is not defined
```
let在同一作用域内不能重复声明
```js
{
    let name = 'lin'
    let name = 'li' // Uncaught SyntaxError: Identifier 'name' has already been declared
}
```
let声明存在暂时性死区，即不能在声明之前使用
```js
console.log(name) // Uncaught ReferenceError: name is not defined
let name = 'lin'
```
在循环中声明迭代变量
```js
for (var i = 0; i < 5; i++) {
    setTimeout(() => console.log(i)) // 5, 5, 5, 5, 5
}
console.log(i) // 5
for (var j = 0; j < 5; j++) {
    setTimeout(() => console.log(j)) // 0, 1, 2, 3, 4
}
console.log(j) // Uncaught ReferenceError: j is not defined
```
- const常量作用域声明

声明的同时必须初始化，且声明后不能重新赋值
```js
const m // Uncaught SyntaxError: Missing initializer in const declaration
const n = 1
n = 2 // Uncaught TypeError: Assignment to constant variable.
```
声明为常量的对象不能重新赋值，但是属性可以修改
```js
const o = {}
o.name = 'lin'
console.log(o) // { name: 'lin' }
// 可以使用Object.freeze()限制属性修改
const fo = Object.freeze({})
fo.name = 'lin'
console.log(fo) // {}
```
> const遵循与let一样的块级作用域和暂时性死区
- 标识符查找

搜索开始于作用域链前端，以给定的名称搜索对应的标识符。如果在局部上下文中找到该标识符，则搜索停止，变量确定；如果没有找到变量名，则继续沿作用域链搜索
## 4.3 垃圾回收
JavaScript通过自动内存管理实现内存分配和闲置资源回收
### 1. 标记清理

垃圾回收程序运行时，会标记内存中存储的所有变量，然后将所有在上下文中的变量以及被上下文中的变量所引用的变量的标记去掉，剩下的带标记的变量就是待删除的，因为上下文中已经访问不到这些变量了。

### 2. 引用计数

声明变量时并赋一个引用值，该值的引用数记为1，如果同一个值又被赋值给另一个变量，则引用数+1；如果保存对该值引用的变量被其他值覆盖了，则引用数-1；当一个值的引用数为0时，就说明无法访问这个值了，因此可以安全回收其内存。垃圾回收程序下次运行的时候就会释放引用数为0的值的内存。
> 存在循环引用问题

### 3. 性能
垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可能造成性能损失，因此垃圾回收的时间调度很重要。

### 4. 内存管理
优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据。如果数据不再必要，那么把它设置为null，从而释放其引用。

解除对一个值的引用并不会自动导致相关内存被回收。解除引用的关键在于确保相关的值已经不在上下文里了，这样在下次垃圾回收时就会被回收。
- 通过const和let声明
    - 块级作用域
- 隐藏类和删除操作
    - 动态添加
    - 动态删除
- 内存泄漏
    - 全局变量
    - 定时器
    - 闭包
- 静态分配与对象池

# 五、基本引用类型
## 5.1 Date
```js
Date.parse('09/23/2021') // 1632326400000， 默认00:00:00
Date.parse('2021/09/23') // 1632326400000， 默认00:00:00
Date.parse('2021-09-23') // 1632355200000， 默认08:00:00
Date.parse('Sep 23, 2021') // 1632326400000, 默认00:00:00

Date.parse('2021/09/23 00:00:00') === Date.parse('2021-09-23 00:00:00') // true

new Date(Date.parse('09/23/2021')) // Thu Sep 23 2021 00:00:00 GMT+0800 (中国标准时间)
// 字符串参数，隐式调用Date.parse()
new Date('09/23/2021')  // Thu Sep 23 2021 00:00:00 GMT+0800 (中国标准时间)
new Date('2021-09-23') // Thu Sep 23 2021 08:00:00 GMT+0800 (中国标准时间)

new Date(2021, 9, 23, 14, 15, 30) // Sat Oct 23 2021 14:15:30 GMT+0800 (中国标准时间)，月份要减1

// 当前系统时间
new Date()
Date.now() // 时间戳
new Date(Date.now())
```

### 1. 继承的方法
```js
new Date().toLocaleString() // '2021/9/23 下午3:38:52'
new Date().toString() // 'Thu Sep 23 2021 15:39:00 GMT+0800 (中国标准时间)'
new Date().valueOf() // 时间戳
new Date('2021/09/23').valueOf() === new Date('2021/09/23').getTime() // true
new Date('2021/09/23').valueOf() === Date.parse('2021/09/23') // true

let date1 = new Date(2021, 10, 23)
let date2 = new Date(2021, 11, 15)
date1 < date2 // true，隐式调用valueOf，比较对应的时间戳
```

### 2. 日期格式化方法
```js
new Date().toDateString() // 'Thu Sep 23 2021'
new Date().toTimeString() // '16:36:21 GMT+0800 (中国标准时间)'
new Date().toLocaleDateString() // '2021/9/23'
new Date().toLocaleString() // '2021/9/23 下午4:37:21'
new Date().toLocaleTimeString() // '下午4:51:01'
new Date().toUTCString() // 'Thu, 23 Sep 2021 09:24:03 GMT'
```
> UTC时间比北京时间慢了8个小时

### 3. 日期/时间组件方法
![image.png](https://res.weread.qq.com/wrepub/epub_34336683_28)
![image.png](https://res.weread.qq.com/wrepub/epub_34336683_29)

## 5.2 RegExp

匹配模式的标记
- g: 全局模式
- i: 不区分大小写
- m：多行模式
- y：粘附模式，表示只查找从lastIndex开始及之后的字符串
- u：Unicode模式，启用Unicode匹配
- s：dotAll模式，表示元字符．匹配任何字符（包括\n或\r）
```js
// 匹配字符串中所有的"at"，区分大小写
let pattern1 = /at/g
// 匹配字符串中第一个"bat"或"cat"，忽略大小写
let pattern2 = /[bc]at/i
```
元字符：有特殊含义的字符，要匹配字符本身，需要使用反斜杠`\`转义
```
( [ { \ ^ $ | } ] ) ? * + .
```

> 推荐[《正则表达式必知必会》](https://weread.qq.com/web/reader/c6932c00718ff68ac6959c4kc81322c012c81e728d9d180)