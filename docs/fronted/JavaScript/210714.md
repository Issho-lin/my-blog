---
title: 重学js系列之《JavaScript高级程序设计(第四版)》
sidebar: 'auto'
date: 2021-07-14
author: Issho Lin
tags:
 - 重学js
categories:
 - Javascript
---

# 一、什么是Javascript

## 1.1 历史回顾

背景：服务端校验表单给用户很不好的体验，网景公司将开发一种客户端脚本语言来处理数据验证提上日程。

> 1995年 Brendan Eich 所在的网景公司与Sun公司结为开发联盟，共同完成LiveScript的开发，后改名为JavaScript

> 微软发布IE3，JScript面世，至此出现了两个版本的JavaScript

> 1997年JavaScript 1.1作为提案被提交给Ecma，TC39打造出ECMA-262，也就是ECMAScript

> 1998年，国际标准化组织（ISO）和国际电工委员会（IEC）也将ECMAScript采纳为标准（ISO/IEC-16262）

## 1.2 JavaScript实现
- ECMAScript
- DOM
- BOM

## 1.3 JavaScript版本
![image.png](https://res.weread.qq.com/wrepub/epub_34336683_8)

# 二、HTML中的Javascript

## 2.1 \<script>元素
- charset：使用src属性指定的代码字符集
- integrity：允许比对接收到的资源和指定的加密签名以验证子资源完整性
- src：表示包含要执行的代码的外部文件
- type：代替language，表示代码块中脚本语言的内容类型；默认text/javascript，如果这个值是module，则代码会被当成ES6模块，而且只有这时候代码中才能出现import和export关键字
- crossorigin：配置相关请求的CORS设置；crossorigin="anonymous"配置文件请求不必设置凭据标志；crossorigin="use-credentials"设置凭据标志，出站请求会包含凭据。
- async: 立即下载脚本并执行，不阻塞其他页面动作
- defer：立即下载脚本，但延迟到文档完全被解析和显示之后再执行
> 与defer不同，async标记的脚本并不保证能按照它们出现的次序执行

## 2.2 行内代码与外部文件
- 可维护性
- 缓存
- 适应未来

## 2.3 文档模式

- 混杂模式：省略文档开头的doctype声明
- 标准模式
```html
<! -- HTML 4.01 Strict -->
<! DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<! -- XHTML 1.0 Strict -->
<! DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<! -- HTML5-->
<! DOCTYPE html>
```

## 2.4 \<noscript>元素

- 浏览器不支持脚本
- 浏览器对脚本的支持被关闭

# 三、语言基础

## 3.1 语法

- 区分大小写
- 标识符
- 注释
- 严格模式
- 语句

## 3.2 关键字与保留字

- 关键字
```js
break         do            in              typeof
case          else          instanceof      var
catch         export        new             void
class         extends       return          while
const         finally       super           with
continue      for           switch          yield
debugger      function      this
default       if            throw
delete        import        try
```
- 保留字
```js
//始终保留：
enum
//严格模式下保留：
implements   package      public
interface    protected    static
let          private
//模块代码中保留：
await
```

## 3.3 变量
### 1. var
- 可以保存任意类型
```js
var message = 'hi'
message = 1 // 合法，不推荐
```
- 声明作用域
```js
// 全局作用域
var str = 'abc'
function fn () {
    // 函数局部作用域
    var num = 123
}
console.log(num) // Uncaught ReferenceError: num is not defined
```
- 声明提升
```js
console.log(num) // undefine
var num = 123
// 相当于
var num
console.log(num)
num = 123
```

### 2. let
- 块级作用域
```js
if (true) {
    let num = 100
}
console.log(num) // Uncaught ReferenceError: num is not defined

// 不允许同一个块作用域中出现冗余声明
let str
let str // Uncaught SyntaxError: Identifier 'str' has already been declared
```
- 暂时性死区
```js
console.log(num) // Uncaught ReferenceError: num is not defined
let num = 123 // 变量声明不会被提升
```
- 全局声明
```js
// 与var不同，let全局声明的变量不会成为window的属性
var num = 123
console.log(window.num) // 123
let str = '123'
console.log(window.str) // undefined
```
- for循环中的声明
```js
for (var i = 0; i < 5; i++) {
    setTimeout(() => console.log(i), 0) // 5,5,5,5,5
}
console.log(i) // 5

for (let j = 0; j < 5; j++) {
    setTimeout(() => console.log(j), 0) // 0,1,2,3,4
}
console.log(j) // Uncaught ReferenceError: j is not defined

```
> 使用var声明迭代变量会渗透到循环体外部，在退出循环时， 迭代变量保存的是导致循环退出的值：5，在之后执行超时逻辑时，所有的i都是同一个变量，因而输出的都是同一个最终值。
而在使用let声明迭代变量时，JavaScript引擎在后台会为每个迭代循环声明一个新的迭代变量，所以每个setTimeout引用的都是不同的变量实例。因此，使用var声明可以借用自执行函数来实现
```js
for (var i = 0; i < 5; i++) {
    (function(j) {
        setTimeout(() => console.log(j), 0) // 0,1,2,3,4
    })(i)
}
```

### 3. const
> const的行为与let基本相同，唯一的区别是声明的同时必须初始化，且不能修改指向的变量的引用
```js
const str // Uncaught SyntaxError: Missing initializer in const declaration
const num = 123
num = 321 // Uncaught TypeError: Assignment to constant variable
const obj = { a: 1 }
obj.a = 2 // ok
```

## 3.4 数据类型
> 通过typeof操作符可以检测数据类型，分别为 "undefined","boolean","string","number","object","function","symbol"
### 1. Undefined
Undefined类型只有一个值，就是特殊值undefined。当使用var或let声明了变量但没有初始化时，就相当于给变量赋值undefined
```js
let num
console.log(num) // undefined
// typeof 声明未初始化的变量，返回"undefined"
console.log(typeof num) // "undefined"
// typeof 检测未声明的变量，也返回"undefined"
console.log(typeof car) // "undefined"
```
### 2. Null
Null类型同样只有一个值，即特殊值null，表示一个空对象指针，这也是给typeof传一个null会返回"object"的原因
```js
let num = null
console.log(typeof num) // "object"
```
### 3. Boolean
Boolean有两个字面值：true和false，其他数据类型的值都可以通过Boolean()转型函数转为布尔值，转换规则如下表：

![img.png](https://res.weread.qq.com/wrepub/epub_34336683_12)
### 4. Number
Number类型使用IEEE754格式表示整数和浮点值
1. 进制
```js
// 十进制
let intNum = 10
// 八进制，第一个数字必须是零（0），然后是相应的八进制数字（数值0~7）

let octalNum = 070 // 8^0 * 0 + 8 ^7 * 1 = 56
// 如果字面量中包含的数字超出0~7，就会忽略前缀的零，后面的数字序列会被当成十进制数
let octalNum2 = 079 // 79

// 十六进制，前缀0x（区分大小写），然后是十六进制数字（0~9以及A~F|a~f）
let hexNum = 0x1f // 16^0 * 15 + 16^1 * 1 = 31


```
> 八进制字面量在严格模式下是无效的，会导致JavaScript引擎抛出语法错误

2. 浮点值
```js
let floatNum1 = 0.1
let floatNum2 = .1 // 有效，但是不推荐
```
因为存储浮点值使用的内存空间是存储整数值的两倍，所以ECMAScript总是想方设法把值转换为整数。在小数点后面没有数字的情况下，数值就会变成整数
```js
let floatNum1 = 1. // 小数点后面没有数字，当成整数1处理
let floatNum2 = 10.0 // 小数点后只有0，当成整数10处理
```
对于非常大或非常小的数值，浮点值可以用科学记数法来表示
```js
let floatNum1 = 3.15e7 // 3.125 * 10^7 = 31250000
let floatNum2 = 3e-17 // 3 * 10^-17
```
浮点值的精确度最高可达17位小数，但在算术计算中会出现精度丢失的情况，这是因为使用了IEEE 754数值，这种错误并非ECMAScript所独有。其他使用相同格式的语言也有这个问题。
```js
0.1 + 0.2 === 0.3 //false，0.30000000000000004
0.15 + 0.15 === 0.3 // true
```
3. 值的范围

ECMAScript可以表示的最小数值保存在`Number.MIN_VALUE`中，这个值在多数浏览器中是`5e-324`；可以表示的最大数值保存在`Number.MAX_VALUE`中，这个值在多数浏览器中是`1.797693134862315 7e+308`。如果某个计算得到的数值结果超出了JavaScript可以表示的范围，那么这个数值会被自动转换为一个特殊的`Infinity`（无穷）值。任何无法表示的负数以`-Infinity`（负无穷大）表示，任何无法表示的正数以`Infinity`（正无穷大）表示。

如果计算返回正Infinity或负Infinity，则该值将不能再进一步用于任何计算，因为Infinity没有可用于计算的数值表示形式。要确定一个值是不是有限大（即介于JavaScript能表示的最小值和最大值之间），可以使用isFinite()函数
```js
let res = Number.MAX_VALUE + Number.MAX_VALUE
isFinite(res) // false
```
>  使用Number.NEGATIVE_INFINITY和Number.POSITIVE_INFINITY可以获取正、负Infinity
4. NaN

用于表示本来要返回数值的操作失败了（而不是抛出错误）。比如，用0除任意数值在其他语言中通常都会导致错误，从而中止代码执行。但在ECMAScript中，0、+0或-0相除会返回NaN
```js
console.log(0/0) // NaN
console.log(-0/+0) // NaN
```
任何涉及NaN的操作始终返回NaN
```js
console.log(NaN + 10) // NaN
```
NaN不等于包括NaN在内的任何值
```js
NaN === NaN // false
```
`isNaN()`用于判断一个值是否是NaN，任何不能转换为数值的值都会导致这个函数返回true
```js
isNaN(NaN) // true
isNaN(10) // false
isNaN('car') // true
isNaN(true) //false，可以转为数值1
```
> isNaN()可以用于测试对象，它会先   调用对象的valueOf()方法，然后再确定返回的值是否可以转换为数值。如果不能，再调用toString()方法，并测试其返回值
5. 数值转换

有3个函数可以将非数值转换为数值：Number()、parseInt()和parseFloat()。Number()是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值

- Number()函数基于如下规则执行转换。
  - 布尔值，true转换为1，false转换为0
  - 数值，直接返回
  - null，返回0
  - undefined，返回NaN
  - 字符串
    - 只包含有效的整型数值字符，转为十进制数值（忽略前面的0）
    - 只包含有效的浮点数值字符，转为相应浮点值（忽略前面的0）
    - 只包含有效的十六进制数值字符，转为十六进制对应的十进制数值
    - 空字符串，返回0
    - 其他，返回NaN
  - 对象，调用valueOf()，并按照上述规则转换，如果结果为NaN，则调用toString()，再按照转换字符串的规则转换
```js
Number('+10') // 10
Number('-10') // -10
Number('0010') // 10
Number('0.1') // 0.1
Number('00.1') // 0.1
Number('0xf') // 15
Number('1a11') // NaN
```
 - parseInt()

从第一个非空字符开始转换，如果第一个字符不是数值字符或加减号，立即返回NaN；否则依次检测每个字符，直到字符串末尾或遇到非数值字符。
如果字符串以“0x”开头，会被解释为十六进制整数
> 如果以“0”开头，且紧跟着数值字符，正常会省略开头的0，按照十进制整数解释，但在非严格模式下会被某些实现解释为八进制整数
```js
let num1 = parseInt('123abc') // 123，解析到非数值字符
let num2 = parseInt('') // NaN
let num3 = parseInt('0xA') // 10，十六进制
let num4 = parseInt('017') // 17，省略开头的0
let num5 = parseInt(22.5) // 22，小数点不是数值字符
```
parseInt()可以接收第二个参数，用于指定底数（进制数）
```js
let num1 = parseInt('0xAF', 16) // 指定解析为十六进制，175
let num3 = parseInt('017', 8) // 指定解析为八进制，15
// 指定了进制数，可以省略前缀
let num2 = parseInt('AF', 16) // 175
let num3 = parseInt('17', 8) // 15
```
 - parseFloat()

 工作方式与parseInt()类似，也是解析到字符串末尾或者解析到一个无效的浮点数值字符为止。这意味着第一次出现的小数点是有效的，但第二次出现的小数点就无效了，此时字符串的剩余字符都会被忽略。parseFloat()只解析十进制数值，不能指定底数
 ```js
 let num1 = parseFloat('123abc') // 123，按整数解析
 let num2 = parseFloat('0xA') // 0，只解析十进制
 let num3 = parseFloat('22.5') // 22.5
 let num4 = parseFloat('22.5.5') // 22.5，第一个小数点有效
 let num5 = parseFloat('0005.5') // 5.5，省略开头的0
 let num6 = parseFloat('3.125e7') // 31250000，科学计数法

 let num7 = parseInt('1e2') // 1，解析到非数值字符
 let num8 = parseFloat('1e2') // 100，解析为科学计数法
 ```
### 5. String
String（字符串）数据类型表示零或多个16位Unicode字符序列，可以使用双引号（"）、单引号（'）或反引号（`）标示
```js
let name = "lin"
let name = 'lin'
let name = `lin`
```
1. 字符字面量
> 字符字面量可以出现在字符串中的任意位置，且被当作单个字符被解释

![img.png](https://res.weread.qq.com/wrepub/epub_34336683_14)
2. 字符串的特点

ECMAScript中的字符串是不可变的（immutable），意思是一旦创建，它们的值就不能变了。要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量
```js
let lang = 'Java'
lang += 'Script'
```
这里，变量lang一开始包含字符串"Java"。紧接着，lang被重新定义为包含"Java"和"Script"的组合，也就是"JavaScript"。整个过程首先会分配一个足够容纳10个字符的空间，然后填充上"Java"和"Script"。最后销毁原始的字符串"Java"和字符串"Script"，因为这两个字符串都没有用了。所有处理都是在后台发生的，而这也是一些早期的浏览器（如Firefox 1.0之前的版本和IE6.0）在拼接字符串时非常慢的原因

3. 转换为字符串
- toString()，可见于数值、布尔值、对象和字符串值。null和undefined没有toString()方法
```js
let age = 11
age.toString() // '11'
let flag = true
flag.toString() // 'true'
```
在对数值调用toString()时，可以接收一个底数参数，即以什么底数来输出数值的字符串表示。默认情况下，toString()返回数值的十进制字符串表示
```js
let num = 10
num.toString() // '10'
num.toString(2) // '1010'
num.toString(8) // '12'
num.toString(10) // '10'
num.toString(16) // 'a'
```
- String() 遵循如下规则
  - 如果值有toString()方法，则调用该方法（不传参数）并返回结果。
  - 如果值是null，返回"null"。
  - 如果值是undefined，返回"undefined"。
```js
let value1 = 10
let value2 = true
let value3 = null
let value4 = undefined
String(value1) // '10'
String(value2) // 'true'
String(value3) // 'null'
String(value4) // 'undefined'
```
> 用加号操作符给一个值加上一个空字符串""也可以将其转换为字符串，详见加号操作符

4. 模板字面量

模板字面量保留换行字符，可以跨行定义字符串
```js
let pageHTML = `
<div>
    <a href="#">
    <span>Jake</span>
    </a>
</div>`;
```
5. 字符串插值

模板字面量最常用的一个特性是支持字符串插值，通过在${}中使用一个JavaScript表达式实现
```js
let value = 5
// 以前，需要通过加号操作符来拼接字符串
let str1 = value + '乘以' + value + '等于' + value * value // 5乘以5等于25
// 现在，可以使用模板字面量插值实现
let str2 = `${value}乘以${value}等于${value * value}`
```
所有插入的值都会使用toString()强制转型为字符串，且任何JavaScript表达式都可以用于插值
```js
let foo = {
    toString: () => 'World'
}
console.log(`Hello, ${foo}!`)  // Hello, World!
```
6. 模板字面量标签函数

模板字面量支持定义标签函数（tag function），通过标签函数可以自定义插值行为。标签函数会接收被插值记号分隔后的模板和对每个表达式求值的结果。
```js
let a = 6;
let b = 9;
function simpleTag(strings, aValExpression, bValExpression, sumExpression) {
    console.log(strings); // ["", " + ", " = ", ""]
    console.log(aValExpression); // 6
    console.log(bValExpression); // 9
    console.log(sumExpression); // 15
    return 'foobar';
}

let untaggedResult = `${ a } + ${ b } = ${ a + b }`;
let taggedResult = simpleTag`${ a } + ${ b } = ${ a + b }`;

console.log(untaggedResult) // '6 + 9 = 15'
console.log(taggedResult) // 'foobar'
```

7. 原始字符串

使用模板字面量可以直接获取原始的模板字面量内容（如换行符或Unicode字符），而不是被转换后的字符表示。

使用默认的String.raw标签函数：
```js
console.log(`\u00A9`) // ©
console.log(String.raw`\u00A9`) // \u00A9
```

### 6. Symbol
Symbol（符号）是ECMAScript 6新增的数据类型。符号是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。
1. 符号的基本用法
```js
let sym = Symbol()
typeof sym // "symbol"

let sym1 = Symbol('foo') // Symbol(foo)
let sym2 = Symbol('foo') // Symbol(foo)
sym1 === sym2 // false
```
Symbol()函数不能与new关键字一起作为构造函数使用，避免创建符号包装对象
```js
// 借用Object()函数实现符号包装对象，不建议
let symObj = Object(Symbol())
typeof symObj // "object"
```
2. 使用全局符号注册表

如果需要共享和重用符号实例，可以用一个字符串作为键，使用Symbol.for()方法在全局符号注册表中创建并重用符号。
```js
let sym1 = Symbol.for('foo')
let sym2 = Symbol.for('foo')
sym1 === sym2 // true
```
Symbol.for()对每个字符串键都执行幂等操作。第一次使用某个字符串调用时，它会检查全局运行时注册表，发现不存在对应的符号，于是就会生成一个新符号实例并添加到注册表中。后续使用相同字符串的调用同样会检查注册表，发现存在与该字符串对应的符号，然后就会返回该符号实例。
> 全局注册表中的符号必须使用字符串键来创建，因此作为参数传给Symbol.for()的任何值都会被转换为字符串

Symbol.keyFor()用来查询全局注册表，接收符号，返回该全局符号对应的字符串键
```js
// 全局符号
let sym1 = Symbol.for('foo')
Symbol.keyFor(sym1) // "foo"
// 普通符号
let sym2 = Symbol('bar')
Symbol.keyFor(sym2) // undefined
// 接收非符号参数，抛出TypeError
Symbol.keyFor(123) // Uncaught TypeError: 123 is not a symbol
```
3. 使用符号作为属性
```js
let s1 = Symbol('foo')
let s2 = Symbol('bar')
let s3 = Symbol('baz')
let s4 = Symbol('qux')

let o = {
    [s1]: 'foo val'
}
o[s2] = 'bar val'

Object.defineProperty(o, s3, { value: 'baz val' })

Object.defineProperties(o, { [s4]: { value: 'qux val' } })

console.log(o)
// { Symbol(bar): "bar val", Symbol(foo): "foo val", Symbol(baz): "baz val", Symbol(qux): "qux val" }
```
Object.getOwnPropertyNames()返回对象实例的常规属性数组，Object.getOwnPropertySymbols()返回对象实例的符号属性数组；Object.getOwnPropertyDescriptors()会返回同时包含常规和符号属性描述符的对象。Reflect.ownKeys()会返回两种类型的键：
```js

```