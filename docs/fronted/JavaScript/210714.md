---
title: 重学js系列之《JavaScript高级程序设计(第四版)》
sidebar: 'auto'
date: 2021-07-14
author: Issho Lin
tags:
 - 重学js
categories:
 - Javascript
---

## 一、什么是Javascript

### 1.1 历史回顾

背景：服务端校验表单给用户很不好的体验，网景公司将开发一种客户端脚本语言来处理数据验证提上日程。

> 1995年 Brendan Eich 所在的网景公司与Sun公司结为开发联盟，共同完成LiveScript的开发，后改名为JavaScript

> 微软发布IE3，JScript面世，至此出现了两个版本的JavaScript

> 1997年JavaScript 1.1作为提案被提交给Ecma，TC39打造出ECMA-262，也就是ECMAScript

> 1998年，国际标准化组织（ISO）和国际电工委员会（IEC）也将ECMAScript采纳为标准（ISO/IEC-16262）

### 1.2 JavaScript实现
- ECMAScript
- DOM
- BOM

### 1.3 JavaScript版本
![image.png](https://res.weread.qq.com/wrepub/epub_34336683_8)

## 二、HTML中的Javascript

### 2.1 \<script>元素
- charset：使用src属性指定的代码字符集
- integrity：允许比对接收到的资源和指定的加密签名以验证子资源完整性
- src：表示包含要执行的代码的外部文件
- type：代替language，表示代码块中脚本语言的内容类型；默认text/javascript，如果这个值是module，则代码会被当成ES6模块，而且只有这时候代码中才能出现import和export关键字
- crossorigin：配置相关请求的CORS设置；crossorigin="anonymous"配置文件请求不必设置凭据标志；crossorigin="use-credentials"设置凭据标志，出站请求会包含凭据。
- async: 立即下载脚本并执行，不阻塞其他页面动作
- defer：立即下载脚本，但延迟到文档完全被解析和显示之后再执行
> 与defer不同，async标记的脚本并不保证能按照它们出现的次序执行

### 2.2 行内代码与外部文件
- 可维护性
- 缓存
- 适应未来

### 2.3 文档模式

- 混杂模式：省略文档开头的doctype声明
- 标准模式
```html
<! -- HTML 4.01 Strict -->
<! DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<! -- XHTML 1.0 Strict -->
<! DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<! -- HTML5-->
<! DOCTYPE html>
```

### 2.4 \<noscript>元素

- 浏览器不支持脚本
- 浏览器对脚本的支持被关闭

## 三、语言基础

### 3.1 语法

- 区分大小写
- 标识符
- 注释
- 严格模式
- 语句

### 3.2 关键字与保留字

- 关键字
```js
break         do            in              typeof
case          else          instanceof      var
catch         export        new             void
class         extends       return          while
const         finally       super           with
continue      for           switch          yield
debugger      function      this
default       if            throw
delete        import        try
```
- 保留字
```js
//始终保留：
enum
//严格模式下保留：
implements   package      public
interface    protected    static
let          private
//模块代码中保留：
await
```

### 3.3 变量
#### 1. var
- 可以保存任意类型
```js
var message = 'hi'
message = 1 // 合法，不推荐
```
- 声明作用域
```js
// 全局作用域
var str = 'abc'
function fn () {
    // 函数局部作用域
    var num = 123
}
console.log(num) // Uncaught ReferenceError: num is not defined
```
- 声明提升
```js
console.log(num) // undefine
var num = 123
// 相当于
var num
console.log(num)
num = 123
```

#### 2. let
- 块级作用域
```js
if (true) {
    let num = 100
}
console.log(num) // Uncaught ReferenceError: num is not defined

// 不允许同一个块作用域中出现冗余声明
let str
let str // Uncaught SyntaxError: Identifier 'str' has already been declared
```
- 暂时性死区
```js
console.log(num) // Uncaught ReferenceError: num is not defined
let num = 123 // 变量声明不会被提升
```
- 全局声明
```js
// 与var不同，let全局声明的变量不会成为window的属性
var num = 123
console.log(window.num) // 123
let str = '123'
console.log(window.str) // undefined
```
- for循环中的声明
```js
for (var i = 0; i < 5; i++) {
    setTimeout(() => console.log(i), 0) // 5,5,5,5,5
}
console.log(i) // 5

for (let j = 0; j < 5; j++) {
    setTimeout(() => console.log(j), 0) // 0,1,2,3,4
}
console.log(j) // Uncaught ReferenceError: j is not defined

```
> 使用var声明迭代变量会渗透到循环体外部，在退出循环时， 迭代变量保存的是导致循环退出的值：5，在之后执行超时逻辑时，所有的i都是同一个变量，因而输出的都是同一个最终值。
而在使用let声明迭代变量时，JavaScript引擎在后台会为每个迭代循环声明一个新的迭代变量，所以每个setTimeout引用的都是不同的变量实例。因此，使用var声明可以借用自执行函数来实现
```js
for (var i = 0; i < 5; i++) {
    (function(j) {
        setTimeout(() => console.log(j), 0) // 0,1,2,3,4
    })(i)
}
```

#### 3. const
> const的行为与let基本相同，唯一的区别是声明的同时必须初始化，且不能修改指向的变量的引用
```js
const str // Uncaught SyntaxError: Missing initializer in const declaration
const num = 123
num = 321 // Uncaught TypeError: Assignment to constant variable
const obj = { a: 1 }
obj.a = 2 // ok
```

### 3.4 数据类型
> 通过typeof操作符可以检测数据类型，分别为 "undefined","boolean","string","number","object","function","symbol"
#### 1. Undefined
Undefined类型只有一个值，就是特殊值undefined。当使用var或let声明了变量但没有初始化时，就相当于给变量赋值undefined
```js
let num
console.log(num) // undefined
// typeof 声明未初始化的变量，返回"undefined"
console.log(typeof num) // "undefined"
// typeof 检测未声明的变量，也返回"undefined"
console.log(typeof car) // "undefined"
```
#### 2. Null
Null类型同样只有一个值，即特殊值null，表示一个空对象指针，这也是给typeof传一个null会返回"object"的原因
```js
let num = null
console.log(typeof num) // "object"
```
#### 3. Boolean
Boolean有两个字面值：true和false，其他数据类型的值都可以通过Boolean()转型函数转为布尔值，转换规则如下表：

![img.png](https://res.weread.qq.com/wrepub/epub_34336683_12)
#### 4. Number
Number类型使用IEEE754格式表示整数和浮点值
1. 进制
```js
// 十进制
let intNum = 10
// 八进制，第一个数字必须是零（0），然后是相应的八进制数字（数值0~7）

let octalNum = 070 // 8^0 * 0 + 8 ^7 * 1 = 56
// 如果字面量中包含的数字超出0~7，就会忽略前缀的零，后面的数字序列会被当成十进制数
let octalNum2 = 079 // 79

// 十六进制，前缀0x（区分大小写），然后是十六进制数字（0~9以及A~F|a~f）
let hexNum = 0x1f // 16^0 * 15 + 16^1 * 1 = 31


```
> 八进制字面量在严格模式下是无效的，会导致JavaScript引擎抛出语法错误

2. 浮点值
```js
let floatNum1 = 0.1
let floatNum2 = .1 // 有效，但是不推荐
```
因为存储浮点值使用的内存空间是存储整数值的两倍，所以ECMAScript总是想方设法把值转换为整数。在小数点后面没有数字的情况下，数值就会变成整数
```js
let floatNum1 = 1. // 小数点后面没有数字，当成整数1处理
let floatNum2 = 10.0 // 小数点后只有0，当成整数10处理
```
对于非常大或非常小的数值，浮点值可以用科学记数法来表示
```js
let floatNum1 = 3.15e7 // 3.125 * 10^7 = 31250000
let floatNum2 = 3e-17 // 3 * 10^-17
```
浮点值的精确度最高可达17位小数，但在算术计算中会出现精度丢失的情况，这是因为使用了IEEE 754数值，这种错误并非ECMAScript所独有。其他使用相同格式的语言也有这个问题。
```js
0.1 + 0.2 === 0.3 //false，0.30000000000000004
0.15 + 0.15 === 0.3 // true
```
3. 值的范围

ECMAScript可以表示的最小数值保存在`Number.MIN_VALUE`中，这个值在多数浏览器中是`5e-324`；可以表示的最大数值保存在`Number.MAX_VALUE`中，这个值在多数浏览器中是`1.797693134862315 7e+308`。如果某个计算得到的数值结果超出了JavaScript可以表示的范围，那么这个数值会被自动转换为一个特殊的`Infinity`（无穷）值。任何无法表示的负数以`-Infinity`（负无穷大）表示，任何无法表示的正数以`Infinity`（正无穷大）表示。

如果计算返回正Infinity或负Infinity，则该值将不能再进一步用于任何计算，因为Infinity没有可用于计算的数值表示形式。要确定一个值是不是有限大（即介于JavaScript能表示的最小值和最大值之间），可以使用isFinite()函数
```js
let res = Number.MAX_VALUE + Number.MAX_VALUE
isFinite(res) // false
```
>  使用Number.NEGATIVE_INFINITY和Number.POSITIVE_INFINITY可以获取正、负Infinity
4. NaN

用于表示本来要返回数值的操作失败了（而不是抛出错误）。比如，用0除任意数值在其他语言中通常都会导致错误，从而中止代码执行。但在ECMAScript中，0、+0或-0相除会返回NaN
```js
console.log(0/0) // NaN
console.log(-0/+0) // NaN
```
任何涉及NaN的操作始终返回NaN
```js
console.log(NaN + 10) // NaN
```
NaN不等于包括NaN在内的任何值
```js
NaN === NaN // false
```
`isNaN()`用于判断一个值是否是NaN，任何不能转换为数值的值都会导致这个函数返回true
```js
isNaN(NaN) // true
isNaN(10) // false
isNaN('car') // true
isNaN(true) //false，可以转为数值1
```
> isNaN()可以用于测试对象，它会先   调用对象的valueOf()方法，然后再确定返回的值是否可以转换为数值。如果不能，再调用toString()方法，并测试其返回值
5. 数值转换

有3个函数可以将非数值转换为数值：Number()、parseInt()和parseFloat()。Number()是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值

- Number()函数基于如下规则执行转换。
  - 布尔值，true转换为1，false转换为0
  - 数值，直接返回
  - null，返回0
  - undefined，返回NaN
  - 字符串
    - 只包含有效的整型数值字符，转为十进制数值（忽略前面的0）
    - 只包含有效的浮点数值字符，转为相应浮点值（忽略前面的0）
    - 只包含有效的十六进制数值字符，转为十六进制对应的十进制数值
    - 空字符串，返回0
    - 其他，返回NaN
  - 对象，调用valueOf()，并按照上述规则转换，如果结果为NaN，则调用toString()，再按照转换字符串的规则转换
```js
Number('+10') // 10
Number('-10') // -10
Number('0010') // 10
Number('0.1') // 0.1
Number('00.1') // 0.1
Number('0xf') // 15
Number('1a11') // NaN
```
 - parseInt()
 - parseFloat()
#### 5. String

#### 6. Symbol